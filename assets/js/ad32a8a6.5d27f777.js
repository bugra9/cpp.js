"use strict";(self.webpackChunk_cpp_js_website=self.webpackChunk_cpp_js_website||[]).push([[3005],{8440:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"guide/features/plugins","title":"Plugins","description":"When integrating Cpp.js into your project via a bundler, the process is streamlined through the use of plugins. This allows for seamless automation of various tasks. This documentation will guide you through the plugin architecture, using the Rollup and Vite plugins as a reference example. Additionally, you have the flexibility to develop and publish your own plugins as needed.","source":"@site/docs/guide/features/plugins.md","sourceDirName":"guide/features","slug":"/guide/features/plugins","permalink":"/docs/guide/features/plugins","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1737096977000,"frontMatter":{},"sidebar":"guide","previous":{"title":"Packages","permalink":"/docs/guide/features/packages"}}');var i=s(7557),r=s(7266);const l={},a="Plugins",o={},d=[{value:"Plugin Structure",id:"plugin-structure",level:3},{value:"Resolving Package Files",id:"resolving-package-files",level:3},{value:"Create Bridge Files and Return Cpp.js Script",id:"create-bridge-files-and-return-cppjs-script",level:3},{value:"Compile",id:"compile",level:3},{value:"Configuring the Development Server",id:"configuring-the-development-server",level:3},{value:"Hot Module Replacement (HMR)",id:"hot-module-replacement-hmr",level:3}];function c(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"plugins",children:"Plugins"})}),"\n",(0,i.jsx)(n.p,{children:"When integrating Cpp.js into your project via a bundler, the process is streamlined through the use of plugins. This allows for seamless automation of various tasks. This documentation will guide you through the plugin architecture, using the Rollup and Vite plugins as a reference example. Additionally, you have the flexibility to develop and publish your own plugins as needed."}),"\n",(0,i.jsx)(n.h3,{id:"plugin-structure",children:"Plugin Structure"}),"\n",(0,i.jsxs)(n.p,{children:["The plugin structure for bundlers can be categorized into two primary segments: general and development. In the general segment, the plugin manages tasks such as locating imported packages (",(0,i.jsx)(n.strong,{children:"resolveId"}),"), reading the relevant files within those packages (",(0,i.jsx)(n.strong,{children:"load"}),"), transforming code (",(0,i.jsx)(n.strong,{children:"transform"}),"), and creating a bundled output (",(0,i.jsx)(n.strong,{children:"generateBundle"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["In the development segment, the focus shifts to tasks like implementing hot module replacement (",(0,i.jsx)(n.strong,{children:"handleHotUpdate"}),") and configuring the development server (",(0,i.jsx)(n.strong,{children:"configureServer"}),")."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"right"},children:"Hook"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"right"},children:(0,i.jsx)(n.strong,{children:"resolveId"})}),(0,i.jsx)(n.td,{children:"locating imported packages"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"right"},children:(0,i.jsx)(n.strong,{children:"load"})}),(0,i.jsx)(n.td,{children:"reading the relevant files"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"right"},children:(0,i.jsx)(n.strong,{children:"transform"})}),(0,i.jsx)(n.td,{children:"transforming code"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"right"},children:(0,i.jsx)(n.strong,{children:"generateBundle"})}),(0,i.jsx)(n.td,{children:"creating a bundled output"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"right"},children:(0,i.jsx)("br",{})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"right"},children:(0,i.jsx)(n.strong,{children:"configureServer"})}),(0,i.jsx)(n.td,{children:"configuring the development server"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"right"},children:(0,i.jsx)(n.strong,{children:"handleHotUpdate"})}),(0,i.jsx)(n.td,{children:"hot module replacement  (HMR)"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," Hook names differ per plugin. The table is based on Rollup and Vite."]}),"\n",(0,i.jsx)(n.h3,{id:"resolving-package-files",children:"Resolving Package Files"}),"\n",(0,i.jsx)(n.p,{children:"A JavaScript file can import a module from the Cpp.js package it depends on."}),"\n",(0,i.jsx)(n.p,{children:"Here is a minimal example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",metastring:'title="cppjs.config.js"',children:"import gdal3js from 'gdal3.js/cppjs.config.js';\n\nexport default {\n    dependencies: [\n        gdal3js,\n    ]\n    paths: {\n        config: import.meta.url,\n    },\n};\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",metastring:'title="src/index.js"',children:"import { initCppJs } from 'gdal3.js/Gdal.h';\n"})}),"\n",(0,i.jsx)(n.p,{children:"To resolve packages files correctly, integration via a hook is required."}),"\n",(0,i.jsx)(n.p,{children:"Here is a minimal example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",metastring:'title="@cpp.js/plugin-rollup/index.js"',children:"\nimport { state, createLib, createBridgeFile, buildWasm, getCppJsScript, getDependFilePath } from 'cpp.js';\nimport fs from 'node:fs';\nimport p from 'node:path';\n\nconst rollupCppjsPlugin = (options, bridges = []) => {\n    return {\n        name: 'rollup-plugin-cppjs',\n        resolveId(source) {\n            if (source === '/cpp.js') {\n                return { id: source, external: true };\n            }\n            if (source === 'cpp.js') {\n                return { id: source, external: false };\n            }\n\n            const dependFilePath = getDependFilePath(source, 'Emscripten-x86_64');\n            if (dependFilePath) {\n                return dependFilePath;\n            }\n\n            return null;\n        },\n    };\n};\n\nexport default rollupCppjsPlugin;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"create-bridge-files-and-return-cppjs-script",children:"Create Bridge Files and Return Cpp.js Script"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"createBridgeFile"})," function in Cpp.js generates a bridge file for the imported header and returns the bridge file path."]}),"\n",(0,i.jsx)(n.p,{children:"Here is a minimal example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-diff",metastring:'title="@cpp.js/plugin-rollup/index.js"',children:"const rollupCppjsPlugin = (options, bridges = []) => {\n+   const headerRegex = new RegExp(`\\\\.(${state.config.ext.header.join('|')})$`);\n+   const moduleRegex = new RegExp(`\\\\.(${state.config.ext.module.join('|')})$`);\n\n    return {\n        name: 'rollup-plugin-cppjs',\n        resolveId(source) {},\n+       async transform(code, path) {\n+           if (!headerRegex.test(path) && !moduleRegex.test(path)) {\n+               return null;\n+           }\n+\n+           const bridgeFile = createBridgeFile(path);\n+           bridges.push(bridgeFile);\n+\n+           return getCppJsScript('Emscripten-x86_64', bridgeFile);\n+       },\n+       load(id) {\n+           if (id === 'cpp.js') {\n+               return getCppJsScript('Emscripten-x86_64');\n+           }\n+           return null;\n+       }\n    };\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"compile",children:"Compile"}),"\n",(0,i.jsxs)(n.p,{children:["For web projects, the code is compiled to WebAssembly using ",(0,i.jsx)(n.code,{children:"createLib"})," and ",(0,i.jsx)(n.code,{children:"buildWasm"})," function. As a result of the compilation, the following files are generated in the ",(0,i.jsx)(n.code,{children:"temp"})," directory:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"NAME.browser.js"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"NAME.wasm"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"NAME.data.txt"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"These files should then be moved to the appropriate location to complete the build process."}),"\n",(0,i.jsx)(n.p,{children:"Here is a minimal example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-diff",metastring:'title="@cpp.js/plugin-rollup/index.js"',children:"const rollupCppjsPlugin = (options, bridges = []) => {\n    return {\n        name: 'rollup-plugin-cppjs',\n        resolveId(source) {},\n        async transform(code, path) {},\n+       async generateBundle() {\n+           createLib('Emscripten-x86_64', 'Source', { isProd: true, buildSource: true });\n+           createLib('Emscripten-x86_64', 'Bridge', { isProd: true, buildSource: false, nativeGlob: [`${state.config.paths.cli}/assets/commonBridges.cpp`, ...bridges] });\n+           await buildWasm('browser', true);\n+           await buildWasm('node', true);\n+           this.emitFile({\n+               type: 'asset',\n+               source: fs.readFileSync(`${state.config.paths.build}/${state.config.general.name}.browser.js`),\n+               fileName: 'cpp.js',\n+           });\n+           this.emitFile({\n+               type: 'asset',\n+               source: fs.readFileSync(`${state.config.paths.build}/${state.config.general.name}.wasm`),\n+               fileName: 'cpp.wasm',\n+           });\n+           const dataFilePath = `${state.config.paths.build}/${state.config.general.name}.data.txt`;\n+           if (fs.existsSync(dataFilePath)) {\n+               this.emitFile({\n+                   type: 'asset',\n+                   source: fs.readFileSync(dataFilePath),\n+                   fileName: 'cpp.data.txt',\n+               });\n+           }\n+       },\n    };\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"configuring-the-development-server",children:"Configuring the Development Server"}),"\n",(0,i.jsx)(n.p,{children:"To ensure Cpp.js operates correctly in the development server environment, follow these steps:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Allow Access to Cpp.js Temp Path:"}),"\nMake sure the development server configuration permits access to the directory where Cpp.js stores its temporary files, typically generated by the ",(0,i.jsx)(n.code,{children:"buildWasm"})," function."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Serve JavaScript Files:"}),"\nConfigure your server to compile and return the ",(0,i.jsx)(n.code,{children:"NAME.browser.js"})," file from the temp path when a request is made to the ",(0,i.jsx)(n.code,{children:"/cpp.js"})," endpoint. This can be achieved using server-specific routing or middleware."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Serve WebAssembly Files:"}),"\nSimilarly, set up your server to return the ",(0,i.jsx)(n.code,{children:"NAME.wasm"})," file from the temp path when a request is made to the ",(0,i.jsx)(n.code,{children:"/cpp.wasm"})," endpoint."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here is a minimal example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",metastring:'title="@cpp.js/plugin-vite/index.js"',children:"import { state, createLib, createBridgeFile, buildWasm } from 'cpp.js';\nimport rollupCppjsPlugin from '@cpp.js/plugin-rollup';\nimport fs from 'node:fs';\n\nconst viteCppjsPlugin = (options) => {\n    let isServe = false;\n    const bridges = [];\n    const headerRegex = new RegExp(`\\\\.(${state.config.ext.header.join('|')})$`);\n    const sourceRegex = new RegExp(`\\\\.(${state.config.ext.source.join('|')})$`);\n\n    return [\n        rollupCppjsPlugin(options, bridges),\n        {\n            name: 'vite-plugin-cppjs',\n            async load(source) {\n                if (isServe && source === '/cpp.js') {\n                    createLib('Emscripten-x86_64', 'Source', { isProd: false, buildSource: true });\n                    createLib('Emscripten-x86_64', 'Bridge', { isProd: false, buildSource: false, nativeGlob: [`${state.config.paths.cli}/assets/commonBridges.cpp`, ...bridges] });\n                    await buildWasm('browser', false);\n                    return fs.readFileSync(`${state.config.paths.build}/${state.config.general.name}.browser.js`, { encoding: 'utf8', flag: 'r' });\n                }\n                return null;\n            },\n            configResolved(config) {\n                isServe = config.command === 'serve';\n                if (isServe) {\n                    config.server.fs.allow.push(state.config.paths.build);\n                }\n            },\n            configureServer(server) {\n                if (isServe) {\n                    server.middlewares.use((req, res, next) => {\n                        if (req.url === '/cpp.wasm') req.url = `/@fs/${state.config.paths.build}/${state.config.general.name}.wasm`;\n                        next();\n                    });\n                }\n            },\n        },\n    ];\n};\n\nexport default viteCppjsPlugin;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"hot-module-replacement-hmr",children:"Hot Module Replacement (HMR)"}),"\n",(0,i.jsxs)(n.p,{children:["Enable HMR by watching native file changes, recompiling with ",(0,i.jsx)(n.code,{children:"createLib"})," and ",(0,i.jsx)(n.code,{children:"buildWasm"}),", and using WebSockets to refresh updates."]}),"\n",(0,i.jsx)(n.p,{children:"Here is a minimal example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-diff",metastring:'title="@cpp.js/plugin-vite/index.js"',children:"const viteCppjsPlugin = (options) => {\n    let isServe = false;\n    const bridges = [];\n    const headerRegex = new RegExp(`\\\\.(${state.config.ext.header.join('|')})$`);\n    const sourceRegex = new RegExp(`\\\\.(${state.config.ext.source.join('|')})$`);\n\n    return [\n        rollupCppjsPlugin(options, bridges),\n        {\n            name: 'vite-plugin-cppjs',\n            async load(source) {},\n            configResolved(config) {},\n            configureServer(server) {},\n+           async handleHotUpdate({ file, server }) {\n+               if (file.startsWith(state.config.paths.build)) {\n+                   return;\n+               }\n+               if (headerRegex.test(file)) {\n+                   const bridgeFile = createBridgeFile(file);\n+                   bridges.push(bridgeFile);\n+                   createLib('Emscripten-x86_64', 'Bridge', { isProd: false, buildSource: false, nativeGlob: [`${state.config.paths.cli}/assets/commonBridges.cpp`, ...bridges] });\n+                   await buildWasm('browser', true);\n+                   server.ws.send({ type: 'full-reload' });\n+               } else if (sourceRegex.test(file)) {\n+                   createLib('Emscripten-x86_64', 'Source', { isProd: false, buildSource: true, bypassCmake: true });\n+                   await buildWasm('browser', false);\n+                   server.ws.send({ type: 'full-reload' });\n+               }\n+           },\n        },\n    ];\n};\n"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},7266:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>a});var t=s(8225);const i={},r=t.createContext(i);function l(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);