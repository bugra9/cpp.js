## What is Cpp.js?
Cpp.js is not just another tool; it's a vision. 
It aims to create performant, secure and powerful cross-platform applications by writing the front-end in JavaScript and the application logic in C++.

Just write the C++ code and call it via javascript. Nothing else needs to be known. Cpp.js performs the following steps in the background;

- Detect which functions are used.
- Generate bridge code for these functions.
- Detect the libraries and source code used.
- Compile the code and create a library.
- Delete unused parts from the library and convert the library to wasm and js files. (Only for WebAssembly)

Cpp.js produces output as both WebAssembly and native. 
The preferred output type is used depending on the platform and expected features. 
Native build is only available for android yet.

### WebAssembly
**Portability**  
WebAssemblyâ€™s binary format is designed to be executable efficiently on a variety of operating systems and instruction set architectures, on the Web and off the Web. 
Single wasm output can be used on most platforms. 
This makes it a good choice for developing cross-platform applications.

**Performance**  
The Wasm stack machine is designed to be encoded in a size- and load-time-efficient binary format. 
WebAssembly aims to execute at native speed by taking advantage of common hardware capabilities available on a wide range of platforms.

**Security**  
The security model of WebAssembly has two important goals: 
1. protect users from buggy or malicious modules, and 
2. provide developers with useful primitives and mitigations for developing safe applications, within the constraints of (1).

Details: <https://webassembly.org/docs/security/> 

### C++ Native Build
**Portability**  
A code compiled with C++ can only run on the platform on which it is compiled. 
For cross-platform support, it must be compiled separately for all platforms to be used.

**Performance**  
It is already native and runs at native speed.


## Uses of WebAssembly / Native
Performing operations at native speed on the client side provides a great advantage. 
No server costs, no connection slowness, much more operations can be done.

By using open source applications written for server, desktop or mobile on the web, very different experiences can be gained. Examples;

- [Sqlite compiled to WebAssembly (sql.js)](https://github.com/sql-js/sql.js/)
- [Gdal compiled to WebAssembly (gdal3.js)](https://github.com/bugra9/gdal3.js)
- [Mobile Map Library compiled to WebAssembly](https://mobile-sdk-web.netlify.app/)

Most companies are rapidly adapting to this situation. Some of the successful examples;

- [Figma](https://www.figma.com/blog/webassembly-cut-figmas-load-time-by-3x/)
- [Adobe Photoshop](https://medium.com/@addyosmani/photoshop-is-now-on-the-web-38d70954365a)
- [AutoCAD](https://www.autodesk.com/blogs/autocad/autocad-web-app-google-io-2018)
- [Unity](https://blog.unity.com/technology/webassembly-is-here)
- [WordPress](https://playground.wordpress.net/)
- [Google Earth](https://blog.chromium.org/2019/06/webassembly-brings-google-earth-to-more.html)
- [Zoom](https://www.infoq.com/news/2020/08/zoom-web-chrome-apis/)
- [TensorFlow.js](https://blog.tensorflow.org/2020/09/supercharging-tensorflowjs-webassembly.html)
- [Docker](https://www.docker.com/blog/docker-wasm-technical-preview/)
